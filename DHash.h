#pragma once

#include <time.h>

const unsigned char  PI_TAB[] =
{
	252, 238, 221,  17, 207, 110,  49,  22, 251, 196, 250,
	218,  35, 197,   4,  77, 233, 119, 240, 219, 147,  46,
	153, 186,  23,  54, 241, 187,  20, 205,  95, 193, 249,
	24, 101,  90, 226,  92, 239,  33, 129,  28,  60,  66,
	139,   1, 142,  79,   5, 132,   2, 174, 227, 106, 143,
	160,   6,  11, 237, 152, 127, 212, 211,  31, 235,  52,
	44,  81, 234, 200,  72, 171, 242,  42, 104, 162, 253,
	58, 206, 204, 181, 112,  14,  86,   8,  12, 118,  18,
	191, 114,  19,  71, 156, 183,  93, 135,  21, 161, 150,
	41,  16, 123, 154, 199, 243, 145, 120, 111, 157, 158,
	178, 177,  50, 117,  25,  61, 255,  53, 138, 126, 109,
	84, 198, 128, 195, 189,  13,  87, 223, 245,  36, 169,
	62, 168,  67, 201, 215, 121, 214, 246, 124,  34, 185,
	3, 224,  15, 236, 222, 122, 148, 176, 188, 220, 232,
	40,  80,  78,  51,  10,  74, 167, 151,  96, 115,  30,
	0,  98,  68,  26, 184,  56, 130, 100, 159,  38,  65,
	173,  69,  70, 146,  39,  94,  85,  47, 140, 163, 165,
	125, 105, 213, 149,  59,   7,  88, 179,  64, 134, 172,
	29, 247,  48,  55, 107, 228, 136, 217, 231, 137, 225,
	27, 131,  73,  76,  63, 248, 254, 141,  83, 170, 144,
	202, 216, 133,  97,  32, 113, 103, 164,  45,  43,   9,
	91, 203, 155,  37, 208, 190, 229, 108,  82,  89, 166,
	116, 210, 230, 244, 180, 192, 209, 102, 175, 194,  57,
	75,  99, 182
};

const unsigned int  P_TAB[] =
{
	0, 8, 16, 24, 32, 40, 48, 56,
	1, 9, 17, 25, 33, 41, 49, 57,
	2, 10, 18, 26, 34, 42, 50, 58,
	3, 11, 19, 27, 35, 43, 51, 59,
	4, 12, 20, 28, 36, 44, 52, 60,
	5, 13, 21, 29, 37, 45, 53, 61,
	6, 14, 22, 30, 38, 46, 54, 62,
	7, 15, 23, 31, 39, 47, 55, 63
} ;

const unsigned long long A[] =
{
	0X8e20faa72ba0b470, 0X47107ddd9b505a38, 0Xad08b0e0c3282d1c, 0Xd8045870ef14980e,
	0X6c022c38f90a4c07, 0X3601161cf205268d, 0X1b8e0b0e798c13c8, 0X83478b07b2468764,
	0Xa011d380818e8f40, 0X5086e740ce47c920, 0X2843fd2067adea10, 0X14aff010bdd87508,
	0X0ad97808d06cb404, 0X05e23c0468365a02, 0X8c711e02341b2d01, 0X46b60f011a83988e,
	0X90dab52a387ae76f, 0X486dd4151c3dfdb9, 0X24b86a840e90f0d2, 0X125c354207487869,
	0X092e94218d243cba, 0X8a174a9ec8121e5d, 0X4585254f64090fa0, 0Xaccc9ca9328a8950,
	0X9d4df05d5f661451, 0Xc0a878a0a1330aa6, 0X60543c50de970553, 0X302a1e286fc58ca7,
	0X18150f14b9ec46dd, 0X0c84890ad27623e0, 0X0642ca05693b9f70, 0X0321658cba93c138,
	0X86275df09ce8aaa8, 0X439da0784e745554, 0Xafc0503c273aa42a, 0Xd960281e9d1d5215,
	0Xe230140fc0802984, 0X71180a8960409a42, 0Xb60c05ca30204d21, 0X5b068c651810a89e,
	0X456c34887a3805b9, 0Xac361a443d1c8cd2, 0X561b0d22900e4669, 0X2b838811480723ba,
	0X9bcf4486248d9f5d, 0Xc3e9224312c8c1a0, 0Xeffa11af0964ee50, 0Xf97d86d98a327728,
	0Xe4fa2054a80b329c, 0X727d102a548b194e, 0X39b008152acb8227, 0X9258048415eb419d,
	0X492c024284fbaec0, 0Xaa16012142f35760, 0X550b8e9e21f7a530, 0Xa48b474f9ef5dc18,
	0X70a6a56e2440598e, 0X3853dc371220a247, 0X1ca76e95091051ad, 0X0edd37c48a08a6d8,
	0X07e095624504536c, 0X8d70c431ac02a736, 0Xc83862965601dd1b, 0X641c314b2b8ee083
};

const unsigned long long C[12][8]=
{
	{  0xdd806559f2a64507, 0x05767436cc744d23, 0xa2422a08a460d315, 0x4b7ce09192676901, 0x714eb88d7585c4fc, 0x2f6a76432e45d016, 0xebcb2f81c0657c1f, 0xb1085bda1ecadae9 },
	{   0xe679047021b19bb7, 0x55dda21bd7cbcd56, 0x5cb561c2db0aa7ca, 0x9ab5176b12d69958, 0x61d55e0f16b50131, 0xf3feea720a232b98, 0x4fe39d460f70b5d7, 0x6fa3b58aa99d2f1a },
	{   0x991e96f50aba0ab2, 0xc2b6f443867adb31, 0xc1c93a376062db09, 0xd3e20fe490359eb1, 0xf2ea7514b1297b7b, 0x06f15e5f529c1f8b, 0x0a39fc286a3d8435, 0xf574dcac2bce2fc7 },
	{  0x220cbebc84e3d12e, 0x3453eaa193e837f1, 0xd8b71333935203be, 0xa9d72c82ed03d675, 0x9d721cad685e353f, 0x488e857e335c3c7d, 0xf948e1a05d71e4dd, 0xef1fdfb3e81566d2 },
	{  0x601758fd7c6cfe57, 0x7a56a27ea9ea63f5, 0xdfff00b723271a16, 0xbfcd1747253af5a3, 0x359e35d7800fffbd, 0x7f151c1f1686104a, 0x9a3f410c6ca92363, 0x4bea6bacad474799 },
	{  0xfa68407a46647d6e, 0xbf71c57236904f35, 0x0af21f66c2bec6b6, 0xcffaa6b71c9ab7b4, 0x187f9ab49af08ec6, 0x2d66c4f95142a46c, 0x6fa4c33b7a3039c0, 0xae4faeae1d3ad3d9 },
	{  0x8886564d3a14d493, 0x3517454ca23c4af3, 0x06476983284a0504, 0x0992abc52d822c37, 0xd3473e33197a93c9, 0x399ec6c7e6bf87c9, 0x51ac86febf240954, 0xf4c70e16eeaac5ec },
	{  0xa47f0dd4bf02e71e,  0x36acc2355951a8d9, 0x69d18d2bd1a5c42f, 0xf4892bcb929b0690, 0x89b4443b4ddbc49a, 0x4eb7f8719c36de1e, 0x03e7aa020c6e4141, 0x9b1f5b424d93c9a7 },
	{  0x7261445183235adb, 0x0e38dc92cb1f2a60, 0x7b2b8a9aa6079c54, 0x800a440bdbb2ceb1, 0x3cd955b7e00d0984, 0x3a7d3a1b25894224, 0x944c9ad8ec165fde, 0x378f5a541631229b },
	{  0x74b4c7fb98459ced, 0x3698fad1153bb6c3, 0x7a1e6c303b7652f4, 0x9fe76702af69334b, 0x1fffe18a1b336103, 0x8941e71cff8a78db, 0x382ae548b2e4f3f3, 0xabbedea680056f52 },
	{  0x6bcaa4cd81f32d1b, 0xdea2594ac06fd85d, 0xefbacd1d7d476e98, 0x8a1d71efea48b9ca, 0x2001802114846679, 0xd8fa6bbbebab0761, 0x3002c6cd635afe94, 0x7bcd9ed0efc889fb },
	{  0x48bc924af11bd720, 0xfaf417d5d9b21b99, 0xe71da4aa88e12852, 0x5d80ef9d1891cc86, 0xf82012d430219f9b, 0xcda43c32bcdf1d77, 0xd21380b00449b17a, 0x378ee767f11631ba }
};




//extern "C"  void XOR_(unsigned long * dest, unsigned long const *A, unsigned long const  *B);
//extern "C"  void XOR_XMM_(unsigned long * dest, unsigned long const *A, unsigned long const  *B);
//extern "C"  void S_(unsigned char *dest, const unsigned char *source, const unsigned char *ptable);
// подстановка значений - в результативный массив подставляются значения из таблицы подстановки
// индекс подставляемого значения равен значению элемента в массиве source
//source - исходный массив  ; dest - результат;  ptable - таблица перестановки
// длина копируемого массива 64 байта
//extern "C"  void P_(unsigned char *dest, const unsigned char *source, const unsigned int *ptable);
// подстановка значений - копирование из исходного массива в результативный с перестановкой байт в соответсвии с таблицей перестановки
//source - исходный массив  ; dest - результат;  ptable - таблица перестановки
// длина копируемого массива 64 байта

//extern "C"  void P1_(unsigned char *dest, const unsigned char *source, const unsigned int *ptable);
// подстановка значений - копирование из исходного массива в результативный с перестановкой байт в соответсвии с таблицей перестановки
//source - исходный массив  ; dest - результат;  ptable - таблица перестановки
// длина копируемого массива 64 байта

//extern "C"  void P2_(unsigned char *dest, const unsigned char *source, const unsigned int *ptable);
// подстановка значений - копирование из исходного массива в результативный с перестановкой байт в соответсвии с таблицей перестановки
//source - исходный массив  ; dest - результат;  ptable - таблица перестановки
// длина копируемого массива 64 байта

void S(unsigned char *dest, const unsigned char *source, const unsigned char *stable);
// подстановка значений - в результативный массив подставляются значения из таблицы подстановки
// индекс подставляемого значения равен значению элемента в массиве source
//source - исходный массив  dest - результат
// длина копируемого массива 64 байта

void P(unsigned char *dest, const unsigned char *source, const unsigned int *ptable);
// перестановка  значений - в результативный массив подставляются значения из исходного массива, переставленные в соответсвии с таблицей перестановки
// ptable
// индекс подставляемого значения равен значению элемента в массиве ptable
//source - исходный массив  dest - результат
// длина копируемого массива 64 байта

void L(unsigned char *dest, const unsigned char *source, const unsigned long long  *atable, const unsigned long long * mask);
// линейное преобразование множества двоичных векторов
//source - исходный массив  dest - результат
// длина копируемого массива 64 байта
//atable - таблица преобразования
//mask - массив из 64 масок для выделения контролируемого бита из 64-битового числа

void l(unsigned long long  *dest, unsigned long long source, const unsigned long long  *atable, const unsigned long long * mask);
// линейное преобразование  двоичного вектора длиной 64 бита (V64)
//source - исходный 64-битный вектор
//dest - результативный 64-битный вектор
//mask - массив из 64 масок для выделения контролируемого бита из 64-битового числа

void LPS(unsigned char *dest, const unsigned char *source);
// составное преобразование LPS
// данные таблиц берутся из статических массивов
// source - исходный 64-байтный вектор
//dest - результативный 64-байтный вектор




class DHash
{

private:
	bool bType; // вид хэш-функции
	// bType=true - используется 256 битная хэш--функция, иначе - 512 битная

	const  unsigned int nByte = 64; // длина хэш-функции в байтах

	unsigned long h[16];
	unsigned long N[16];
	unsigned long Sigma[16];

	unsigned long long Mask[64];  // массив масок для выделения бита 

	int Nk; // номер элемента в масиве K, доступного для обработки
	unsigned long K[13][16]; // матрица коэффициентов для функции сжатия


public:
// Конструктор класса 
	// b - тип расчётного значения хэш-функции ( true - используется 256 битная функция, false - 512 битная функция
	DHash(bool b) : bType{ b }
	{
	// инициализация массива масок для выделения бита
		Mask[0] = 1;
		for (int i = 0; i < 63; i++)
			Mask[i + 1] = Mask[i] << 1;
	}

	// сброс- инициализация расчёта хэш-функции для нового блока данных
	void Reset()
	{
		memset(N, 0, nByte);
		memset(Sigma, 0, nByte);
		if (bType)
			memset(h, 1, nByte);
		else             memset(h, 0, nByte);
	}

	//  расчёт хэш-функций  для сообщения произвольной длины
	// buf - сообщение (массив байт)
	// len - его длина в байтах
	void Calculate(unsigned  char *buf, size_t len); 

	//  расчёт хэш-функций  для части  сообщения 
	// длина части сообщения, за исключением последней, должна быть кратна 512 байт
	//buf - часть сообщения
	//len - его длина
	void CalculatePart(unsigned  char *buf, size_t len);

	//  расчёт хэш-функций  для последней части  сообщения 
	// длина части сообщения, за исключением последней, может быть не кратна 512 бит (64 байт)
	//buf - часть сообщения
	//len - его длина
	void CalculateLastPart(unsigned  char* buf, size_t len);


	// завершение расчёта хэш-функции
	// используется, если расчёт значений хэш-функции выполняется по частям
	void End();

	void getHash(unsigned long *h);
	// вернёт значение хэш-функции
	// возвращаемые данные определяются в зависимости от режима работы(256 или 512 битный хэш)
	// h - буфер для записи значений. Длина буфера должна быть не менее 256 бит
	// если режим работы bType=true (256 битный хэш) 512 бит если режим работы bType= false (512 битный хэш)
	

	// Схема вычисления следующая:
	// один буфер:
	// Reset
	// Calculate (для 1 буфера)

	// несколько буферов с данными:
	// Reset
	// CalculatePart -   для каждой части данных (каждого буфера)
	// CalculateLastPart 
	// End - завершение расчёта

	// !!! после вычисления исходные данные (содержимое входного массива) затираются!


private:

	void Update(unsigned long *buf, unsigned int msize);
		// расчёт хэш-функции для блока данных длиной не более 512 бит

	void Gn(unsigned long *m);
	//функция  сжатия
	// m - исходный блок данных, подлежащий обработке
	// в процессе работы значение блока данных изменяется!!!
	void KCalculate();
	// циклический расчёт коэффициентов K
	// до начала расчёта должен быть определён коэффициент K[0]

	void XOR(unsigned long * dest, unsigned long const *A, unsigned long const  *B);
	// исключающее ИЛИ двух 32- битных беззнаковых массивов (A и B)

	void X(unsigned long *A, unsigned long const *B);  
	// исключающее или двух 32-битных беззнаковых массивов А и В длиной 512 бит с записью результата по адресу первого массива

	void LPS(unsigned char *dest, const unsigned char *source);
	// составное преобразование LPS
	// данные таблиц берутся из статических массивов
	// source - исходный 64-байтный вектор
	//dest - результативный 64-байтный вектор

	void LPSX(unsigned long *dest, const unsigned long *K, const unsigned long *source);
		// составное преобразование LPSX
		// преобразование с записью результата в новый массив destination
		// данные таблиц берутся из статических массивов
		// source - исходный 64-байтный вектор
		// K - 64- байтный множитель
		//dest - результативный 64-байтный вектор

	void LPSXX(const unsigned long *K, unsigned long *source);
	// составное преобразование LPSX
	// преобразование с записью результата "на месте" - в исходный массив source
	// данные таблиц берутся из статических массивов
	// source - исходный 64-байтный вектор
	// K - 64- байтный множитель
	
	
	

};





	
	


